#-----------------------------------------------------------------------------
# Copyright (c) 2020 Kahlan Gibson
# kahlangibson<at>ece.ubc.ca
#
# Permission to use, copy, and modify this software and its documentation is
# hereby granted only under the following terms and conditions. Both the
# above copyright notice and this permission notice must appear in all copies
# of the software, derivative works or modified versions, and any portions
# thereof, and both notices must appear in supporting documentation.
# This software may be distributed (but not offered for sale or transferred
# for compensation) to third parties, provided such third parties agree to
# abide by the terms and conditions of this notice.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS, AS WELL AS THE UNIVERSITY
# OF BRITISH COLUMBIA DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
# INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO 
# EVENT SHALL THE AUTHORS OR THE UNIVERSITY OF BRITISH COLUMBIA BE LIABLE
# FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
# IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#---------------------------------------------------------------------------

"""Syncopation

Usage:
    syncopation make [--no_synth_directives] [--add_synth_directives] [--no_sync_hardware] [--pipeline]
    syncopation modelsim [--log=<LOG_FILE>]
    syncopation synth [--log=<LOG_FILE>] [--enhanced_synthesis] [--no_synthesis] [--no_sta]
    syncopation timing
    syncopation -h|--help

Options:
    -h --help               Show this screen
    --no_synth_directives   No annotations in generated RTL for Syncopation circuits
    --add_synth_directives  Add synthesis directives to baseline circuit
    --no_sync_hardware      No syncopation DMs, clock generator
    --pipeline              Pipeline the divisor selection logic; use conservative predict
    --enhanced_synthesis    If no enhanced synthesis constraints are found, generate them. If found, resynthesize
    --no_synthesis          Perform performance eval without resynthesizing design
    --no_sta                Perform synthesis without performance eval/fine-grained sta
    --log=<LOG_FILE>        Modelsim log file generated by simulation and used to assess Syncopation performance
"""

import subprocess, os, shutil
from .misc import execute, clean_file, save, read_file
import getopt
from docopt import docopt
from .project import generate_top_module, insert_syncoption_hardware, profile_rtl, add_synthesis_directives, get_module_data
from .synthesis import perform_sta, get_dynamic_timing, generate_clock_settings, generate_mif_files, get_simulation_performance, get_timing_constraints
from .settings import *

#################################
######### Setup Project #########
#################################
def make_project(c_file, no_synth_directives, add_synth_directives, no_sync_hardware, pipeline):
    """ Generates Syncopation Hardware, Project Files """

    # create project name based on input file
    project_name = c_file.split(".")[0]
    verilog_file = project_name+'.v'
    project_folder = os.path.dirname(os.path.abspath(c_file))
    output_directory = project_name+"_files"

    # Create folder and generate Makefile
    print("INFO: Creating project...") 
    if os.path.exists(output_directory):
        shutil.rmtree(output_directory, ignore_errors=True)
    os.makedirs(output_directory)
    # remove pll, verilog, tcl...
    if os.path.exists(os.path.join(project_folder,"pll")):
        shutil.rmtree(os.path.join(project_folder,"pll"))
    if os.path.exists(os.path.join(project_folder,"sdc")):
        shutil.rmtree(os.path.join(project_folder,"sdc"))
    if os.path.exists(os.path.join(project_folder,"dynamic_clock.v")):
        os.remove(os.path.join(project_folder,"dynamic_clock.v"))
    if os.path.exists(os.path.join(project_folder,"setup_sync_proj.tcl")):
        os.remove(os.path.join(project_folder,"setup_sync_proj.tcl"))
    if os.path.exists(os.path.join(project_folder,project_name+"_record.v")):
        os.remove(os.path.join(project_folder,project_name+"_record.v"))
    if os.path.exists(os.path.join(project_folder,"board_top.v")):
        os.remove(os.path.join(project_folder,"board_top.v"))
    if os.path.exists(os.path.join(project_folder,"connect_top.v")):
        os.remove(os.path.join(project_folder,"connect_top.v"))

    # make:
    print("INFO: Cleaning previous files...")
    execute(["make","clean"], cd=project_folder, wait=True)
    execute(["make"], cd=project_folder, wait=True)
    # backup copy of verilog
    shutil.copy(verilog_file,project_name+"_record.v")

    # Clean away sdc timing constraint files
    # enhanced synthesis constraints
    sdc_file = os.path.join(project_folder, 'sdc', "path_delays.sdc")
    clean_file(sdc_file)
    # debug constraints
    sdc_file_debug = os.path.join(project_folder, 'sdc', "path_delays_debug.sdc")
    clean_file(sdc_file_debug)
    sdc_file_fmax = os.path.join(project_folder, 'sdc', "fmax_delay.sdc")
    clean_file(sdc_file_fmax)

    # make p:
    print("INFO: Generating Quartus Project...")
    # project constraints
    sdc_file_project = project_name+".sdc"
    clean_file(sdc_file_project) # to be repopulated later

    # move plls
    shutil.copytree(os.path.join(TOOL_PATH,"pll",str(int(PLL_CLOCK))), os.path.join(project_folder,"pll"))
    # move clock file
    shutil.copy(os.path.join(TOOL_PATH, "verilog", "dynamic_clock.v"), os.path.join(project_folder, "dynamic_clock.v"))
    # move tcl file
    shutil.copy(os.path.join(TOOL_PATH, "tcl", "setup_sync_proj.tcl"), os.path.join(project_folder, "setup_sync_proj.tcl"))

    execute(["make","p"], cd=project_folder, wait=True)

    # add synthesis directives
    add_directives = bool(no_sync_hardware==False and no_synth_directives==False) or bool(no_sync_hardware==True and add_synth_directives==True)
    if add_directives: 
        print("INFO: Adding synthesis directives")
        add_synthesis_directives(verilog_file)

    if no_sync_hardware: # make project without syncopation hardware
        # custom sdc
        with open(sdc_file_project, 'w') as out_f:
            out_f.write("create_clock -period 2.000 -name CLOCK_50 [get_ports CLOCK_50]\n")
            out_f.write("derive_pll_clocks\n")
            out_f.write("derive_clock_uncertainty\n")
        shutil.copy(os.path.join(TOOL_PATH, "verilog", "de1_top.v"), os.path.join(project_folder, "connect_top.v"))
        profile_rtl(verilog_file)
        get_module_data(pipeline, verilog_file)
    else: 
        with open(sdc_file_project, 'w') as out_f:
            print("INFO: Saving project sdc file "+sdc_file_project)
            out_f.write("create_clock -period 20.000 -name CLOCK_50 [get_ports CLOCK_50]\n")
            out_f.write("derive_pll_clocks\n")
            out_f.write("create_clock -period 2 -name dyn_clk [get_nodes connect_top_INST|dynamic_clock:CLOCK_GEN|clk]\n")
            out_f.write("set_false_path -from dyn_clk -to {connect_top_INST|PLL_INST|pll_inst|altera_pll_i|general[0].gpll~PLL_OUTPUT_COUNTER|divclk}\n")
            out_f.write("derive_clock_uncertainty")
        shutil.copy(os.path.join(TOOL_PATH, "verilog", "syncopation_top.v"), os.path.join(project_folder, "connect_top.v"))
        
        # Profile rtl to determine parameters
        profile_rtl(verilog_file)

        # Insert Syncopation hardware
        insert_syncoption_hardware(pipeline, verilog_file)

    generate_top_module(no_sync_hardware, pipeline, verilog_file)
    execute(["quartus_sh", "-t", "setup_sync_proj.tcl"], cd=project_folder, wait=True)

    # save settings such as pipeline/synth directives
    settings = {
        'pipeline':pipeline,
        'no_synth_directives':no_synth_directives,
        'no_sync_hardware':no_sync_hardware
    }
    settings = save(os.path.join(output_directory, "settings.json"), settings)

###################################
############# Simulate ############
###################################
def run_modelsim(c_file, log_file=None):
    """ Runs modelsim to test results """
    print("INFO: Starting Modelsim...")
    project_name = c_file.split(".")[0]
    verilog_file = project_name+'.v'
    project_folder = os.path.dirname(os.path.abspath(c_file))
    output_directory = project_name+"_files"

    if log_file == None: log_file = os.path.join(output_directory, "modelsim.log")
    out = execute(["make","v"], cd=project_folder, print_output=True)
    save(log_file, out)

############################################
############# Synthesize design ############
############################################
def make_synthesis(c_file, enhanced_synthesis, no_synth, no_sta, log_file=None):
    """ Synthesize hardware """
    # create project name based on input file
    project_name = c_file.split(".")[0]
    verilog_file = project_name+'.v'
    project_folder = os.path.dirname(os.path.abspath(c_file))
    output_directory = project_name+"_files"
    if log_file == None: log_file = os.path.join(output_directory, "modelsim.log")

    # load settings such as pipeline/synth directives
    settings = read_file(os.path.join(output_directory, "settings.json"))
    pipeline = settings['pipeline']
    no_synth_directives = settings['no_synth_directives']
    no_sync_hardware = settings['no_sync_hardware']
    
    print("INFO: Starting Synthesis...")

    # timing constraints
    # enhanced synthesis constraints - clear before synthesis if not specified
    sdc_file = os.path.join(project_folder, 'sdc', "path_delays.sdc")
    # debug constraints
    sdc_file_debug = os.path.join(project_folder, 'sdc', "path_delays_debug.sdc")
    clean_file(sdc_file_debug)
    # fmax
    sdc_file_fmax = os.path.join(project_folder, 'sdc', "fmax_delay.sdc")
    clean_file(sdc_file_fmax)

    generating_es = False
    if not enhanced_synthesis: # clean file to not impact timing
        clean_file(sdc_file)
        if no_synth:
            print("INFO: Skipping synthesis pass because --no_synth was specified...")
        else:
            print("INFO: Synthesizing...")
            execute(["make","f"], cd=project_folder, print_output=True)
    else: 
        sdc_contents = read_file(sdc_file)
        if len(sdc_contents) > 1: 
            if no_synth:
                print("INFO: Skipping enhanced synthesis pass because --no_synth was specified...")
            else:
                print("INFO: Synthesizing with enhanced synthesis constraints...")
                execute(["make","f"], cd=project_folder, print_output=True)
        else: 
            generating_es = True
            if no_synth:
                print("INFO: Skipping synthesis pass because --no_synth was specified. Generating ES constraints...")
            else:
                print("INFO: Synthesizing...")
                execute(["make","f"], cd=project_folder, print_output=True)

    if no_sync_hardware:
        print("INFO: Checking max operating frequency...")
        result = execute(['quartus_sta', '-t', os.path.join(TOOL_PATH, 'tcl','fmax_check.tcl')], cd=project_folder, quiet=True)
        freq = [l for l in result.split('\n') if 'MHz' in l]
        freq = freq[0].strip().split()[2]
        print("FMAX: "+ freq)
        print("INFO: Saving result to "+os.path.join(output_directory,'no_sync_fmax.csv'))
        save(os.path.join(output_directory,'no_sync_fmax.csv'), [freq])
        profile_rtl(verilog_file)
        get_module_data(pipeline, verilog_file)
        get_timing_constraints(verilog_file, True)
    else: # with syncopation hardware
        clean_file(sdc_file)
        result = execute(['quartus_sta', '-t', os.path.join(TOOL_PATH, 'tcl','report_longest.tcl')], cd=project_folder, quiet=True)
        result = result.split('\n')
        slack = [l for l in result if "Slack: "  in l]
        slack = float(slack[0].split()[-1])
        max_frequency = 1000.0/(2-slack)
        print("FMAX "+str(max_frequency))
        print("Note: Syncopation performance is not determined by FMAX.")
        print("      Effective frequency is more indicative of circuit performance.")

        if no_sta:
            print("INFO: Skipping updating fine-grained STA because --no_sta was specified.")
            print("INFO: Skipping updating memory contents and project because --no_sta was specified.")
            print("      Run `quartus_cdb --update_mif top` and `quartus_asm top` to update memories.")
        else:
            print("INFO: Executing tcl script for fine-grained static timing analysis...")
            perform_sta(verilog_file)
            print("INFO: Determining dynamic clock settings...")
            
        get_dynamic_timing(verilog_file, False) # enhanced_synthesis is False to generate correct sdc constraints
        if not no_sta: get_timing_constraints(verilog_file)
        clean_file(sdc_file_fmax)
        generate_clock_settings(verilog_file, pipeline) # determine frequencies per state
        generate_mif_files(verilog_file, pipeline) # populate divisor memories
        if not no_sta:
            print("INFO: Updating project memory contents...")
            # execute(["quartus_cdb", "--update_mif", "top"], cd=project_folder, wait=True)
            # execute(["quartus_asm", "top"], cd=project_folder, wait=True)

        if no_synth_directives:
            print("INFO: Synthesis directives not present. Configuration may result in data corruption")
        # run modelsim to determine performance
        if not os.path.exists(log_file):
            print("INFO: Simulation log not found.")
            print("INFO: A custom modelsim log can be specified by running `syncopation modelsim` with the option --log=<LOG_FILE>")
            # need to run simulation...
            print("INFO: Performing default simulation. This may take some time...")
            run_modelsim(c_file, log_file=log_file)
        if enhanced_synthesis and not generating_es:
            print("INFO: Evaluating Syncopation enhanced synthesis performance...")
        else:
            print("INFO: Evaluating Syncopation performance...")

        get_simulation_performance(verilog_file, pipeline, log_file=log_file)

        if enhanced_synthesis: 
            print("INFO: Generating enhanced synthesis constraints.")
            if generating_es: 
                print("      Run synthesis again to determine performance...")
            get_dynamic_timing(verilog_file, enhanced_synthesis)

    clean_file(sdc_file_debug)

#############################################
############# Generate timing files #########
#############################################
def make_timing(c_file, clean_timing):
    """ Make SDC File """
    print("Generating SDC File")
    # create project name based on input file
    project_name = c_file.split(".")[0]
    verilog_file = project_name+'.v'
    project_folder = os.path.dirname(os.path.abspath(c_file))
    output_directory = project_name+"_files"

    settings = read_file(os.path.join(output_directory, "settings.json"))
    pipeline = settings['pipeline']
    no_synth_directives = settings['no_synth_directives']
    no_sync_hardware = settings['no_sync_hardware']

    sdc_file = os.path.join(project_folder, 'sdc', "path_delays.sdc")
    sdc_file_debug = os.path.join(project_folder, 'sdc', "path_delays_debug.sdc")
    sdc_file_fmax = os.path.join(project_folder, 'sdc', "fmax_delay.sdc")
    clean_file(sdc_file_debug)
    clean_file(sdc_file)
    clean_file(sdc_file_fmax)

    result = execute(['quartus_sta', '-t', os.path.join(TOOL_PATH, 'tcl','report_longest.tcl')], cd=project_folder, quiet=True)
    result = result.split('\n')
    slack = [l for l in result if "Slack: "  in l]
    slack = float(slack[0].split()[-1])
    max_frequency = 1000.0/(2-slack)
    print("FMAX "+str(max_frequency))
    print("Note: Syncopation performance is not determined by FMAX.")
    print("      Effective frequency is more indicative of circuit performance.")
    
    print("INFO: Executing tcl script for fine-grained static timing analysis...")
    perform_sta(verilog_file)
    print("INFO: Determining dynamic clock settings...")
    
    get_dynamic_timing(verilog_file, False) # enhanced_synthesis is False to generate correct sdc constraints
    get_timing_constraints(verilog_file)
    generate_clock_settings(verilog_file, pipeline)
    generate_mif_files(verilog_file, pipeline)

    print("INFO: Updating project memory contents...")
    execute(["quartus_cdb", "--update_mif", "top"], cd=project_folder, wait=True)
    execute(["quartus_asm", "top"], cd=project_folder, wait=True)

    print("INFO: generated file "+sdc_file_debug)
    print("INFO: generated file "+sdc_file_fmax)

####################################
########### Main Routine ###########
####################################
def main():
    # Get user arguments
    options = docopt(__doc__)

    src = ''
    if os.path.exists('Makefile'):
        with open('Makefile', 'r') as mfile:
            for line in mfile:
                if 'SRCS' in line:
                    src = line.split('=')[1].strip()
                if 'NAME' in line:
                    name = line.split('=')[1].strip()
    else:
        print("ERROR: No makefile found in current directory.")
        exit(0)

    if src == '':
        src = name + '.c'
    
    if not os.path.exists(src): 
        print("ERROR: No source file {} found in current directory.".format(src))
        exit(0)

    # Run Syncopation using user options
    if options["make"]:
        make_project(src, options["--no_synth_directives"], options["--add_synth_directives"], options["--no_sync_hardware"], options["--pipeline"])
    if options["modelsim"]:
        run_modelsim(src, log_file=options["--log"])
    if options["synth"]:
        make_synthesis(src, options["--enhanced_synthesis"], options["--no_synthesis"], options["--no_sta"], options["--log"])
    if options["timing"]:
        make_timing(src)
